use std::env;

pub fn hex2bin<'a>(c: char) -> &'a str {
    let b: &'a str = match c {
        '0' => "0000",
        '1' => "0001",
        '2' => "0010",
        '3' => "0011",
        '4' => "0100",
        '5' => "0101",
        '6' => "0110",
        '7' => "0111",
        '8' => "1000",
        '9' => "1001",
        'a' => "1010",
        'b' => "1011",
        'c' => "1100",
        'd' => "1101",
        'e' => "1110",
        'f' => "1111",
        _ => "",
    };
    b
}

pub fn sex2base64(b: &str) -> char {
    match b {
        "000000" => 'A',
        "000001" => 'B',
        "000010" => 'C',
        "000011" => 'D',
        "000100" => 'E',
        "000101" => 'F',
        "000110" => 'G',
        "000111" => 'H',
        "001000" => 'I',
        "001001" => 'J',
        "001010" => 'K',
        "001011" => 'L',
        "001100" => 'M',
        "001101" => 'N',
        "001110" => 'O',
        "001111" => 'P',
        "010000" => 'Q',
        "010001" => 'R',
        "010010" => 'S',
        "010011" => 'T',
        "010100" => 'U',
        "010101" => 'V',
        "010110" => 'W',
        "010111" => 'X',
        "011000" => 'Y',
        "011001" => 'Z',
        "011010" => 'a',
        "011011" => 'b',
        "011100" => 'c',
        "011101" => 'd',
        "011110" => 'e',
        "011111" => 'f',
        "100000" => 'g',
        "100001" => 'h',
        "100010" => 'i',
        "100011" => 'j',
        "100100" => 'k',
        "100101" => 'l',
        "100110" => 'm',
        "100111" => 'n',
        "101000" => 'o',
        "101001" => 'p',
        "101010" => 'q',
        "101011" => 'r',
        "101100" => 's',
        "101101" => 't',
        "101110" => 'u',
        "101111" => 'v',
        "110000" => 'w',
        "110001" => 'x',
        "110010" => 'y',
        "110011" => 'z',
        "110100" => '0',
        "110101" => '1',
        "110110" => '2',
        "110111" => '3',
        "111000" => '4',
        "111001" => '5',
        "111010" => '6',
        "111011" => '7',
        "111100" => '8',
        "111101" => '9',
        "111110" => '+',
        "111111" => '/',
        _ => '=',
    }
}
fn hex2base64(hex: String) -> String {
    let mut base: String = String::new();
    let mut buffer: String = String::new();
    for c in hex.chars() {
        buffer += hex2bin(c);
    }
    // println!("{}", buffer);
    if buffer.len() % 6 != 0 {
        for _ in 0..(6 - buffer.len() % 6) {
            buffer += "0";
        }
    }
    // println!("{}", buffer);
    let mut buf: String;
    let mut y = 0;
    for i in (6..buffer.len() + 6).step_by(6) {
        buf = String::from(&buffer[y..i]);
        y = i;
        // println!("{}", buf);
        base.push(sex2base64(&buf[0..buf.len()]));
    }
    base
}
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() > 1 {
        let hex: String = args[1].clone();
        let ans: String = hex2base64(hex);
        println!("{}", ans);
    }
}
